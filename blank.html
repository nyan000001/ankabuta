<!doctype html>
<html>
<head>
<title>ankabuta</title>
<meta name="robots" content="noindex">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans&family=Noto+Color+Emoji&display=swap" rel="stylesheet">
<style>
html, body, #top { height:100%; }
body { font-size:7pt; font-family:'Open Sans', 'Noto Color Emoji', sans-serif; padding:0; margin:0; line-height:13px; }
body.blank * { display:none; }
#top { display:flex; }
#top > div { min-width:200px; overflow:auto scroll; margin-bottom:40px; }
p { white-space:pre-wrap; padding:3px; margin:0; word-wrap:break-word; cursor:default; }
h1 { position:sticky; top:0; background:#fff; font-size:8pt; margin:0; padding:0; z-index:1; }
p.disconnected { opacity:.5; text-decoration:line-through; }
#bottom { position:fixed; bottom:0; min-width:660px; width:100%; text-align:center; }
form { display:inline-block; margin:8px; }
input[type=number] { width:40px; }
@media (prefers-color-scheme:dark) {
	body, h1 { background:#000; color:#fff; }
	::-webkit-scrollbar { width:15px; height:15px; }
	::-webkit-scrollbar-track { background:#222; }
	::-webkit-scrollbar-thumb { background-color:#333; border:1px solid #555; }
	::-webkit-scrollbar-corner { background:#333; }
}
</style>
</head>
<body class="blank">
<div id="top"></div>
<div id="bottom">
<form id="kickform">
<input id="name" spellcheck="false">
<input type="number" id="kicktime" value="0">
<input type="submit" value="Kick">
</form>
<form id="regexform">
<input id="regex">
<output id="currentregex"></output>
<input type="submit" value="Regex">
</form>
<form id="lockform">
<input type="number" id="locktime" value="0">
<input type="submit" value="Lock">
</form>
</div>
<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const get = id => document.getElementById(id);
const login = password => {
	socket.emit('LOGIN', password);
	get('name').oninput = () => {
		const name = get('name').value;
		const ps = document.getElementsByTagName('p');
		for(let i = 0; i < ps.length; i++) {
			ps[i].style.background = ps[i].classList.contains(name)? '#f00': 'transparent';
		}
	}
	get('kickform').onsubmit = e => {
		e.preventDefault();
		socket.emit('KICK', password, get('name').value, get('kicktime').value);
	}
	get('regexform').onsubmit = e => {
		e.preventDefault();
		socket.emit('REGEX', password, get('regex').value);
	}
	get('lockform').onsubmit = e => {
		e.preventDefault();
		socket.emit('LOCK', password, get('locktime').value);
	}
}
socket.once('disconnect', () => console.log('Connection lost!'));
socket.once('log', (records, rooms, regex) => {
	document.body.classList.remove('blank');
	const roomdivs = {};
	const addroom = room => {
		if(roomdivs[room]) return;
		const div = document.createElement('div');
		const h1 = document.createElement('h1');
		h1.textContent = room;
		div.append(h1);
		get('top').append(div);
		roomdivs[room] = div;
	}
	for(const room of rooms) addroom(room);
	const addrecord = (room, name, hash, ...arr) => {
		const addtext = (text, bool) => {
			const p = document.createElement('p');
			let html = '';
			const arr = text.split(/\[\{(.*?)\}\]/s);
			for(let i = 0; i < arr.length; i++) {
				text = arr[i].replace(/</g, '&lt;').replace(/>/g, '&gt;');
				if(i % 2) {
					html += '<pre>'+text+'</pre>';
				} else {
					html += text.
						replace(/\[!(.*?)!\]/g, '<span class="rainbow">$1</span>').
						replace(/\[#([0-9a-f]{3})(.*?)#\]/gi, '<span style="color:#$1">$2</span>').
						replace(/\[°([0-9a-f]{3})(.*?)°\]/gi, '<span style="color:hsl($1, 100%, 50%)">$2</span>').
						replace(/\[\*(.*?)\*\]/g, '<b>$1</b>').
						replace(/\[\/(.*?)\/\]/g, '<i>$1</i>').
						replace(/\[_(.*?)_\]/g, '<span style="text-decoration:underline">$1</span>').
						replace(/\[-(.*?)-\]/g, '<span style="text-decoration:line-through">$1</span>');
				}
			}
			p.innerHTML = html;
			if(!room) room = '(not in a room)';
			if(!roomdivs[room]) addroom(room);
			roomdivs[room].append(p);
			if(bool) {
				p.classList.add(name, hash);
				if([name, hash].includes(get('name').value)) {
					p.style.background = '#f00';
				}
				const highlight = name => {
					get('name').value = name;
					const ps = document.getElementsByTagName('p');
					for(let i = 0; i < ps.length; i++) {
						ps[i].style.background = ps[i].classList.contains(name)? '#f00': 'transparent';
					}
					get('name').focus();
				}
				p.onclick = e => highlight(p.classList.contains(name)? name: '');
				p.oncontextmenu = e => {
					e.preventDefault();
					highlight(hash);
				}
			}
			roomdivs[room].scrollTo({ top:roomdivs[room].scrollHeight, left:0, behavior:'smooth' });
		}
		const cmd = arr.shift();
		let boldname = '[*'+name+'*]';
		if(!cmd) {
			if(name == 'New regex') get('currentregex').textContent = hash;
			addtext([name, hash].reduce((acc, curr) => acc+' '+(typeof curr == 'string'? curr: '[/'+curr+'/]')));
		} else if(cmd == 'join' && typeof arr[0] == 'string') {
			room = arr[0].replace(/\s/g, '_').replace(/^#?/, '#').slice(0, 30);
			addroom(room);
			addtext(boldname+' joined', true);
		} else if(cmd == 'say') {
			if(typeof arr[0] != 'string') arr[0] = JSON.stringify(arr[0]);
			addtext(boldname+': '+arr[0], true);
		} else if(cmd == 'disconnect') {
			addtext(boldname+' has disconnected', true)
			const ps = document.getElementsByClassName(name);
			while(ps.length) {
				ps[0].classList.add('disconnected');
				ps[0].classList.remove(name);
			}
		} else if(cmd == 'sendAll' || cmd == 'sendOnly') {
			let verb = 'says to';
			if(typeof arr[0] == 'boolean') verb = ['removes from', 'adds to'][arr.shift()?1:0];
			if(!arr[0]) return;
			let included = arr[1];
			let excluded = 'others';
			if(cmd == 'sendAll') {
				included = arr[1]? 'everyone but '+arr[1]: 'everyone';
				excluded = arr[1];
			}
			if(!included) return;
			if(typeof arr[0] == 'object') arr[0] = JSON.stringify(arr[0]);
			let text = boldname+' '+verb+' '+included+': '+arr[0];
			if(arr[2]) {
				if(typeof arr[2] == 'object') arr[2] = JSON.stringify(arr[2]);
				text += '\n'+boldname+' '+verb+' '+excluded+': '+arr[2];
			}
			addtext(text, true);
		} else {
			addtext(boldname+' '+[cmd, ...arr].reduce((acc, curr) => acc+' '+(typeof curr == 'string'? curr: '[/'+curr+'/]')), true);
		}
	}
	for(const record of records) addrecord(...record);
	socket.on('log', addrecord);
});
</script>
</body>
</html>